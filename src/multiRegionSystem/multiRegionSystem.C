/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2013-2015 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "fvCFD.H"
#include "coupledFvMatrices.H"

#include "multiRegionSystem.H"
#include "HashPtrTable.H"
#include "IOobjectList.H"

#include "pimpleControl.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{
    template<>
    const char* Foam::NamedEnum
    <
        Foam::multiRegionSystem::couplingMethods,
        2
    >::names[] =
    {
        "partitioned",
        "coupled"
    };
}

const Foam::NamedEnum
<
    Foam::multiRegionSystem::couplingMethods,
    2
> Foam::multiRegionSystem::couplingMethodsNames_;


// * * * * * * * * * * * * * * * Private functions * * * * * * * * * * * * * //

template< template<class> class M, class T>
void Foam::multiRegionSystem::assembleAndSolveCoupledMatrix
(
    PtrList<GeometricField<T, fvPatchField, volMesh> >& flds,
    word fldName
) const
{
    // get number of coupled fields per field name
    label nEqns = 0;

    forAll (flds, fldI)
    {
        if(flds[fldI].name() == fldName)
        {
            nEqns++;
        }
    }

    if (nEqns == 0) return;

    Info<< fldName << ": "
       << "Number of coupled fields : " << nEqns << endl;

    // assemble and solve block matrix system
    coupledFvMatrix<T> coupledEqns(nEqns);

    // assemble and solve all matrices one-by-one
    label nReg = 0;
    forAll (regions_(), regI)
    {
        // Check if coupled field is registered to region 
        // and if it is of correct type
        if
        (
            !(
                regions_()[regI].mesh().thisDb().foundObject
                <GeometricField<T, fvPatchField, volMesh> >
                (
                    fldName
                )
            )
        )
        {
            continue;
        }

        regionType& rg = const_cast<regionType&>(regions_()[regI]);

        M<T>& eqn =
            rg.getCoupledEqn<M,T>
            (
                fldName + rg.mesh().name() + "Eqn"
            );

        coupledEqns.set(nReg, &eqn);

        nReg++;
    }

    coupledEqns.solve
    (
        regions_()[0].mesh().solutionDict().solver(fldName + "coupled")
    );
}

template< template<class> class M, class T>
void Foam::multiRegionSystem::assembleAndSolveEqns
(
    word fldName
) const
{
    // assemble and solve all matrices one-by-one
    forAll (regions_(), regI)
    {
        regionType& rg = const_cast<regionType&>(regions_()[regI]);

        // Check if coupled field is registered to region mesh
        // and if it is of correct type
        // and if this region holds the equation
        if
        (
            !(
                rg.foundCoupledEqn
                (
                    fldName + rg.mesh().name() + "Eqn"
                ) 
                && 
                rg.mesh().thisDb().foundObject
                <GeometricField<T, fvPatchField, volMesh> >
                (
                    fldName
                )
            )
        )
        {
            continue;
        }

        // It is an error to use regionCouplePolyPatch
        // TODO: need more consistency checks:
        //  - Is the regionCouple bc set for fldName?
        //  - AND: Is this region adjacent to the relevant regionInterface?
        fvMesh& mesh = const_cast<fvMesh&>(regions_()[regI].mesh());

        {
            const polyPatchList& patches = mesh.boundaryMesh();

            forAll (patches, patchI)
            {
                if (isType<regionCouplePolyPatch>(patches[patchI]))
                {
                    FatalError  << "Error: Attempt to solve partitioned " 
                                << "with a patch of type " 
                                << regionCouplePolyPatch::typeName
                                << exit(FatalError);
                }
            }

            // Force recalculation of weights
            mesh.surfaceInterpolation::movePoints();
        }

//        auto& eqn =
//            rg.getCoupledEqn<M,T>
//            (
//                fldName + rg.mesh().name() + "Eqn"
//            );

        Info<< nl 
            << "Solving for " << fldName
            << " in " << rg.mesh().name()
            << endl;


//        pimpleControl pimpleControlRegion(rg.mesh());

//        while (pimpleControlRegion.correctNonOrthogonal())
//        {
            // set coupled equation again
            // since boundary conditions have been updated
            rg.setCoupledEqns();

            M<T>& eqn =
                rg.getCoupledEqn<M,T>
                (
                    fldName + rg.mesh().name() + "Eqn"
                );

            rg.relaxEqn<T>(eqn);

            eqn.solve();

            rg.postSolve();
//        }
    }
}

template<class T>
void Foam::multiRegionSystem::assembleCoupledFields
(
    PtrList<GeometricField<T, fvPatchField, volMesh> >& flds,
    const hashedWordList& fldNms
) const
{
    label n = 0;

    forAll (regions_(), regI) // go through all regions
    {
        // get list of all objects registered to region
        IOobjectList objects
        (
            regions_()[regI].mesh(),
            "0"
        );

        // get list of field objects of requested type
        IOobjectList volTypeObjects = 
            objects.lookupClass
            (
                GeometricField<T, fvPatchField, volMesh>::typeName
            );

        for
        (
            IOobjectList::iterator iter = volTypeObjects.begin();
            iter != volTypeObjects.end();
            ++iter
        )
        {
            if
            (
                fldNms.contains(iter()->name())
            )
            {
                const GeometricField<T, fvPatchField, volMesh>& fld =
                    regions_()[regI].mesh().thisDb().lookupObject
                    <GeometricField<T, fvPatchField, volMesh> >
                    (
                        iter()->name()
                    );

                flds.setSize(flds.size() + 1);

                flds.set(n, fld);

                n++;

                // Info<< "Name of coupled field in region "
                //    << regions_()[regI].name() << " : " 
                //    << iter()->name() << endl;
            }
        }
    }
}

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::multiRegionSystem::multiRegionSystem
(
    const Time& runTime
)
:
    IOdictionary
    (
        IOobject
        (
            "multiRegionProperties",
            runTime.constant(),
            runTime,
            IOobject::MUST_READ,
            IOobject::NO_WRITE
        )
    ),

    runTime_(runTime),

    regions_(),
    interfaces_(),

    partitionedCoupledScalarFlds_(),
    partitionedCoupledVectorFlds_(),
    partitionedCoupledSymmTensorFlds_(),
    partitionedCoupledTensorFlds_(),
    partitionedCoupledVector4Flds_(),

    monolithicCoupledScalarFlds_(),
    monolithicCoupledVectorFlds_(),
    monolithicCoupledSymmTensorFlds_(),
    monolithicCoupledTensorFlds_(),
    monolithicCoupledVector4Flds_(),

    partitionedCoupledFldNames_(),
    monolithicCoupledFldNames_(),

    dnaControls_()
{
    Info << "Creating regions:" << endl;
    regions_.set
    (
        new regionTypeList
        (
            runTime_
        )
    );

    Info << nl << "Creating region interfaces:" << endl;
    interfaces_.set
    (
        new regionInterfaceList
        (
            runTime_
        )
    );

    // set unique list of coupled field names
    partitionedCoupledFldNames_ = interfaces_->pcFldNames();
    monolithicCoupledFldNames_ = interfaces_->mcFldNames();

    // set up DNA convergence control for partitioned coupling
    forAll (partitionedCoupledFldNames_, fldI)
    {
        dnaControls_.set
        (
            partitionedCoupledFldNames_[fldI],
            new dnaControl
            (
                runTime_,
                partitionedCoupledFldNames_[fldI],
                interfaces()
            )
        );
    }

    //- assemble list of coupled fields
    assembleCoupledFields<scalar>
        (partitionedCoupledScalarFlds_, partitionedCoupledFldNames_);

    assembleCoupledFields<vector>
        (partitionedCoupledVectorFlds_, partitionedCoupledFldNames_);

    assembleCoupledFields<tensor>
        (partitionedCoupledTensorFlds_, partitionedCoupledFldNames_);

    assembleCoupledFields<symmTensor>
        (partitionedCoupledSymmTensorFlds_, partitionedCoupledFldNames_);

    assembleCoupledFields<vector4>
        (partitionedCoupledVector4Flds_, partitionedCoupledFldNames_);

    assembleCoupledFields<scalar>
        (monolithicCoupledScalarFlds_, monolithicCoupledFldNames_);

    assembleCoupledFields<vector>
        (monolithicCoupledVectorFlds_, monolithicCoupledFldNames_);

    assembleCoupledFields<tensor>
        (monolithicCoupledTensorFlds_, monolithicCoupledFldNames_);

    assembleCoupledFields<symmTensor>
        (monolithicCoupledSymmTensorFlds_, monolithicCoupledFldNames_);

    assembleCoupledFields<vector4>
        (monolithicCoupledVector4Flds_, monolithicCoupledFldNames_);
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

Foam::multiRegionSystem::~multiRegionSystem()
{
    regions_->clear();
}


// * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * * //

void Foam::multiRegionSystem::preSolve()
{
    // Correct region properties and update meshes
    regions_->preSolve();

    // Update interfaces on mesh change (motion or topology)
    interfaces_->update();
}


Foam::scalar Foam::multiRegionSystem::getMinDeltaT()
{
    //- set deltaT based on volumetric stability criterion
    scalar minRegionDeltaT = regions_->getMinDeltaT();
    //- set deltaT based on interface stability criterion
    scalar minInterfaceDeltaT = interfaces_->getMinDeltaT();

    return min(minRegionDeltaT, minInterfaceDeltaT);
}


void Foam::multiRegionSystem::solve()
{
    // Set coupled equations
    regions_->setCoupledEqns();

    interfaces_->detach();

    // Solve individual region physics
    regions_->solveRegion();

    // Solve region-region coupling (partitioned)

    //- Solve pressure-velocity system using PIMPLE
    if (partitionedCoupledFldNames_.contains("UpPimple"))
    {
        while (dnaControls_["UpPimple"]->loop())
        {
            // PIMPLE p-U-coupling
            regions_->solvePIMPLE();

            // ALE mesh motion corrector
            regions_->meshMotionCorrector();

            interfaces_->update();
        }
    }

    //- Solve other region-region coupled fields   
    forAll (partitionedCoupledFldNames_, fldI)
    {
        word fldName = partitionedCoupledFldNames_[fldI];

        // outer coupling loop
        while (dnaControls_[fldName]->loop())
        {
            assembleAndSolveEqns<fvMatrix, scalar>(fldName);

            assembleAndSolveEqns<fvMatrix, vector>(fldName);

            assembleAndSolveEqns<fvMatrix, tensor>(fldName);

            assembleAndSolveEqns<fvBlockMatrix, vector4>(fldName);

//            assembleAndSolveEqns<symmTensor>(fldName);
        }
    }


    // Solve region-region coupling (monolithic)
    interfaces_->attach();

    forAll (monolithicCoupledFldNames_, fldI)
    {
        word fldName = monolithicCoupledFldNames_[fldI];

        assembleAndSolveCoupledMatrix<fvMatrix, scalar>
        (
            monolithicCoupledScalarFlds_, fldName
        );

        assembleAndSolveCoupledMatrix<fvMatrix, vector>
        (
            monolithicCoupledVectorFlds_, fldName
        );

        assembleAndSolveCoupledMatrix<fvMatrix, tensor>
        (
            monolithicCoupledTensorFlds_, fldName
        );

//        assembleAndSolveCoupledMatrix<symmTensor>
//        (
//            monolithicCoupledSymmTensorFlds_, fldName
//        );

//        assembleAndSolveCoupledMatrix<fvBlockMatrix, vector4>
//        (
//            monolithicCoupledVector4Flds_, fldName
//        );
    }
}

void Foam::multiRegionSystem::setCoupledEqns()
{
    regions_->setCoupledEqns();
}


Foam::regionTypeList& Foam::multiRegionSystem::regions()
{
    return regions_();
}

Foam::regionInterfaceList& Foam::multiRegionSystem::interfaces()
{
    return interfaces_();
}


//bool multiRegionSystem::read()
//{
//    if (IOdictionary::read())
//    {
//        bool readOK = true;

//        lookup("coupledRegionInterfaces") >> coupledInterfaces_;

//        return readOK;
//    }

//    return false;
//}

// ************************************************************************* //
