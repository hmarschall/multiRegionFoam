/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | foam-extend: Open Source CFD
   \\    /   O peration     | Version:     4.1
    \\  /    A nd           | Web:         http://www.foam-extend.org
     \\/     M anipulation  | For copyright notice see file Copyright
-------------------------------------------------------------------------------
License
    This file is part of foam-extend.

    foam-extend is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.

    foam-extend is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with foam-extend.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "movingInterfacePatches.H"
#include "polyTopoChanger.H"
#include "foamTime.H"
#include "addToRunTimeSelectionTable.H"

#include "polyPatchID.H"
#include "vector.H"
#include "wedgeFaPatch.H"
#include "wedgeFaPatchFields.H"
#include "slipFaPatchFields.H"
#include "fixedValueFaPatchFields.H"
#include "slipFvPatchFields.H"
#include "symmetryFvPatchFields.H"
#include "wallFvPatch.H"
#include "fvcMeshPhi.H"

#include "EulerDdtScheme.H"
#include "CrankNicolsonDdtScheme.H"
#include "backwardDdtScheme.H"

#include "coordinateSystem.H"
#include "scalarMatrices.H"


// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //

namespace Foam
{
    defineTypeNameAndDebug(movingInterfacePatches, 0);
}


// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //

void Foam::movingInterfacePatches::initializeData()
{
    if (motionDict_.found("neighbourMesh"))
    {
        isInterface_ = true;
    }

    if (!isInterface_ && isFsiInterface_)
    {
        FatalErrorIn("movingInterfacePatches::initializeData()")
                    << "You cannot specify a movingInterfacePatch as a "
                    << "fsiInterface without specifying the neighbour mesh "
                    << " and the neighbour patch"
                        << abort(FatalError);
    }

    if (isFsiInterface_)
    {
        accModel();
    }
    else
    {
        fixedSurfacePatches_ = wordList
        (
            motionDict_.lookup("fixedSurfacePatches")
        );

        pointNormalsCorrectionPatches_ = wordList
        (
            motionDict_.lookup("pointNormalsCorrectionPatches")
        );

        normalMotionDir_ = Switch
        (
            motionDict_.lookup("normalMotionDir")
        );
    }

    smoothing_ = Switch
    (
        motionDict_.lookupOrDefault<Switch>("smoothing", false)
    );

    if
    (
        motionDict_.subDict("smoothSurfaceMeshCoeffs")
        .found("smoothingFrequency")
    )
    {
        smoothingFrequency_ = readInt
        (
            motionDict_.subDict("smoothSurfaceMeshCoeffs")
            .lookup("smoothingFrequency")
        );
    }

    if
    (
        motionDict_.subDict("smoothSurfaceMeshCoeffs")
        .found("smoothingTolerance")
    )
    {
        smoothingTolerance_ = readScalar
        (
            motionDict_.subDict("smoothSurfaceMeshCoeffs")
            .lookup("smoothingTolerance")
        );
    }

    // Set surface patch index
    {
        const word surfacePatchName(name_);

        polyPatchID patch(surfacePatchName, mesh().boundaryMesh());

        if (!patch.active())
        {
            FatalErrorInFunction
                << "Patch name " << surfacePatchName << " not found."
                << abort(FatalError);
        }

        surfacePatchID_ = patch.index();
    }

    // Set point normal correction for finite area mesh
    {
        boolList& correction = aMesh().correctPatchPointNormals();

        forAll(pointNormalsCorrectionPatches_, patchI)
        {
            word patchName = pointNormalsCorrectionPatches_[patchI];

            label patchID = aMesh().boundary().findPatchID(patchName);

            if(patchID == -1)
            {
                FatalErrorIn
                (
                    "movingInterfacePatches::initializeData(...)"
                )   << "Patch name for point normals correction does not exist"
                    << abort(FatalError);
            }

            correction[patchID] = true;
        }
    }

    // Read motion direction
    if (!normalMotionDir_ && !isFsiInterface_)
    {
        motionDir_ = vector(motionDict_.lookup("motionDir"));
        motionDir_ /= mag(motionDir_) + SMALL;
    }

    // Set unique name for faMesh
    aMesh().rename(patch().name() + "FaMesh");
}

void Foam::movingInterfacePatches::makeFaMesh() const
{
    if (!aMeshPtr_.empty())
    {
        FatalErrorIn("movingInterfacePatches::makeFaMesh()")
            << "finite area mesh already exists"
            << abort(FatalError);
    }

    aMeshPtr_.set(new faMesh(mesh(), "faMeshDefinition"));

    // Set unique name for faMesh
    aMeshPtr_->rename(patch().name() + "FaMesh");

    // Set point normal correction patches
    boolList& correction = aMeshPtr_->correctPatchPointNormals();

    forAll(pointNormalsCorrectionPatches_, patchI)
    {
        word patchName = pointNormalsCorrectionPatches_[patchI];

        label patchID = aMeshPtr_->boundary().findPatchID(patchName);

        if (patchID == -1)
        {
            FatalErrorIn
            (
                "freeSurface::makeFaMesh()"
            )   << "Patch name for point normals correction does not exist"
                << abort(FatalError);
        }

        correction[patchID] = true;
    }
}

void Foam::movingInterfacePatches::makeControlPoints()
{
    if (debug)
    {
        Info<< "movingInterfacePatches::makeControlPoints() : "
            << "making control points"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!controlPointsPtr_.empty())
    {
        FatalErrorIn("movingInterfacePatches::makeInterpolators()")
            << "patch to patch interpolators already exists"
            << abort(FatalError);
    }

    IOobject controlPointsHeader
    (
        "controlPoints",
        mesh().time().timeName(),
        mesh(),
        IOobject::MUST_READ
    );

    if (controlPointsHeader.headerOk())
    {
        controlPointsPtr_.set
        (
            new vectorIOField
            (
                IOobject
                (
                    "controlPoints",
                    mesh().time().timeName(),
                    mesh(),
                    IOobject::MUST_READ,
                    IOobject::AUTO_WRITE
                )
            )
        );
    }
    else
    {
        controlPointsPtr_.set
        (
            new vectorIOField
            (
                IOobject
                (
                    "controlPoints",
                    mesh().time().timeName(),
                    mesh(),
                    IOobject::NO_READ,
                    IOobject::AUTO_WRITE
                ),
                aMesh().areaCentres().internalField()
            )
        );

        initializeControlPointsPosition();
    }
}

void Foam::movingInterfacePatches::makeTotalDisplacement()
{
    if (debug)
    {
        Info<< "movingInterfacePatches::makeTotalDisplacement() : "
            << "making zero total points displacement"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!totalDisplacementPtr_.empty())
    {
        FatalErrorIn("movingInterfacePatches::makeTotalDisplacement()")
            << "total points displacement already exists"
            << abort(FatalError);
    }

    totalDisplacementPtr_.set
    (
        new vectorIOField
        (
            IOobject
            (
                "totalDisplacement",
                mesh().time().timeName(),
                mesh(),
                IOobject::NO_READ,
                IOobject::AUTO_WRITE
            ),
            vectorField
            (
                mesh().boundaryMesh()[patchID()].nPoints(),
                vector::zero
            )
        )
    );
}

void Foam::movingInterfacePatches::makePrevDisplacement()
{
    if (debug)
    {
        Info<< "movingInterfacePatches::makePrevDisplacement() : "
            << "making zero previous points displacement"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!prevDisplacementPtr_.empty())
    {
        FatalErrorIn("movingInterfacePatches::makePrevDisplacement()")
            << "total points displacement already exists"
            << abort(FatalError);
    }

    prevDisplacementPtr_.set
    (
        new vectorIOField
        (
            IOobject
            (
                "prevDisplacement",
                mesh().time().timeName(),
                mesh(),
                IOobject::NO_READ,
                IOobject::AUTO_WRITE
            ),
            totalDisplacement()
        )
    );
}

void Foam::movingInterfacePatches::makeTotalSweptVolCorr()
{
    if (debug)
    {
        Info<< "movingInterfacePatches::makeTotalSweptVolCorr() : "
            << "making zero total swept volume correction"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!totalSweptVolCorrPtr_.empty())
    {
        FatalErrorIn("movingInterfacePatches::makeTotalSweptVolCorr()")
            << "total swept volume correction already exists"
            << abort(FatalError);
    }

    totalSweptVolCorrPtr_.set
    (
        new scalarIOField
        (
            IOobject
            (
                "totalSweptVolCorr",
                mesh().time().timeName(),
                mesh(),
                IOobject::NO_READ,
                IOobject::AUTO_WRITE
            ),
            scalarField
            (
                mesh().boundaryMesh()[patchID()].faceCentres().size(),
                0.0
            )
        )
    );
}

void Foam::movingInterfacePatches::makeMotionPointsMask()
{
    DebugInFunction
        << "making motion points mask" << nl;

    if (!motionPointsMaskPtr_.empty())
    {
        FatalErrorInFunction
            << "motion points mask already exists"
            << abort(FatalError);
    }

    motionPointsMaskPtr_.set
    (
        new scalarField
        (
            mesh().boundaryMesh()[patchID()].nPoints(),
            1
        )
    );

    // Mark free surface boundary points
    // that belong to processor patches
    forAll(aMesh().boundary(), patchI)
    {
        if
        (
            aMesh().boundary()[patchI].type()
         == processorFaPatch::typeName
        )
        {
            const labelList& patchPoints =
                aMesh().boundary()[patchI].pointLabels();

            forAll(patchPoints, pointI)
            {
                motionPointsMask()[patchPoints[pointI]] = -1;
            }
        }
    }

    // Mark fixed free surface boundary points
    for (const word& patchName : fixedSurfacePatches_)
    {
        const label fixedPatchID = aMesh().boundary().findPatchID(patchName);

        if (fixedPatchID == -1)
        {
            FatalErrorInFunction
                << "Wrong faPatch name in the fixedSurfacePatches list"
                << " defined in the dynamicMeshDict dictionary"
                << abort(FatalError);
        }

        const labelList& patchPoints =
            aMesh().boundary()[fixedPatchID].pointLabels();

        forAll(patchPoints, pointI)
        {
            motionPointsMask()[patchPoints[pointI]] = 0;
        }
    }

    // Mark free surface boundary points
    // at the axis of 2-D axisymmetic cases
    forAll(aMesh().boundary(), patchI)
    {
        if
        (
            aMesh().boundary()[patchI].type()
         == wedgeFaPatch::typeName
        )
        {
            const wedgeFaPatch& wedgePatch =
                refCast<const wedgeFaPatch>(aMesh().boundary()[patchI]);

            Info << "Axis points: " << endl;

//            if(wedgePatch.axisPoint() > -1)
            forAll(wedgePatch.axisPoints(), apI)
            {
                motionPointsMask()[wedgePatch.axisPoints()[apI]] = 0;
//                motionPointsMask()[wedgePatch.axisPoint()] = 0;

                Info<< wedgePatch.axisPoints()[apI]
                    << aMesh().points()[wedgePatch.axisPoints()[apI]]
                    << endl;
            }
        }
    }
}


void Foam::movingInterfacePatches::makeDirections()
{
    DebugInFunction
        << "make displacement directions for points and control points" << nl;

    if (!pointsDisplacementDirPtr_.empty() || !facesDisplacementDirPtr_.empty())
    {
        FatalErrorInFunction
            << "points, control points displacement directions already exist"
            << abort(FatalError);
    }

    pointsDisplacementDirPtr_.set
    (
        new vectorField
        (
            mesh().boundaryMesh()[patchID()].nPoints(),
            pTraits<vector>::zero
        )
    );

    facesDisplacementDirPtr_.set
    (
        new vectorField
        (
            mesh().boundaryMesh()[patchID()].size(),
            pTraits<vector>::zero
        )
    );

    if (!normalMotionDir())
    {
        if (mag(motionDir_) < SMALL)
        {
            FatalErrorInFunction
                << "Zero motion direction"
                << abort(FatalError);
        }

        facesDisplacementDir() = motionDir_;
        pointsDisplacementDir() = motionDir_;
    }

    updateDisplacementDirections();
}

void Foam::movingInterfacePatches::makeAccModel()
{
    if (debug)
    {
        Info<< "movingInterfacePatches::makeAccModel() : "
            << "making convergence acceleration model"
            << endl;
    }

    // It is an error to attempt to recalculate
    // if the pointer is already set
    if (!accModelPtr_.empty())
    {
        FatalErrorIn("movingInterfacePatches::makeAccModel()")
            << "acceleration model already exists"
            << abort(FatalError);
    }

    if (!isFsiInterface_)
    {
        FatalErrorIn("movingInterfacePatches::makeAccModel()")
            << "Trying to create an acceleration model for a "
            << "movingInterfacePatch that is not part of an fsi interface"
            << abort(FatalError);
    }

    accModelPtr_.set
    (
        accelerationModel<vector>::New
        (
            mesh().time(),
            motionDict_
        ).ptr()
    );

    accModelPtr_->initialize(totalDisplacement());
}

void Foam::movingInterfacePatches::updateDisplacementDirections()
{
    if(normalMotionDir())
    {
        // Update point displacement correctionengine/engineTopoChangerMesh/deformingEngineMesh/
        pointsDisplacementDir() = aMesh().pointAreaNormals();

        // Correct point displacement direction
        // at the "centerline" symmetryPlane which represents the axis
        // of an axisymmetric case
        forAll(aMesh().boundary(), patchI)
        {
            if(aMesh().boundary()[patchI].type() == wedgeFaPatch::typeName)
            {
                const wedgeFaPatch& wedgePatch =
                    refCast<const wedgeFaPatch>(aMesh().boundary()[patchI]);

                vector axis = wedgePatch.axis();

                label centerLinePatchID =
                    aMesh().boundary().findPatchID("centerline");

                if(centerLinePatchID != -1)
                {
                    const labelList& pointLabels =
                        aMesh().boundary()[centerLinePatchID].pointLabels();

                    forAll(pointLabels, pointI)
                    {
                        vector dir =
                            pointsDisplacementDir()[pointLabels[pointI]];

                        dir = (dir&axis)*axis;
                        dir /= mag(dir);

                        pointsDisplacementDir()[pointLabels[pointI]] = dir;
                    }
                }
                else
                {
                    Info << "Warning: centerline polyPatch does not exist. "
                        << "Surface points displacement directions "
                        << "will not be corrected at the axis (centerline)"
                        << endl;
                }

//                break;
            }
        }

        label nWedgePatches = 0;
        vector wedgeDirVec = vector::zero;
        forAll(mesh().boundaryMesh(), patchI)
        {
            if (isA<wedgePolyPatch>(mesh().boundaryMesh()[patchI]))
            {
                const wedgePolyPatch& wpp = refCast<const wedgePolyPatch>
                (
                    mesh().boundaryMesh()[patchI]
                );

                nWedgePatches++;
                wedgeDirVec += cmptMag(wpp.centreNormal());
            }
        }

        reduce(nWedgePatches, maxOp<label>());

        if (nWedgePatches)
        {
            reduce(wedgeDirVec, sumOp<vector>());

            wedgeDirVec /= mag(wedgeDirVec);

            vectorField dir = pointsDisplacementDir();

            for (direction cmpt=0; cmpt<vector::nComponents; cmpt++)
            {
                if (wedgeDirVec[cmpt] > 1e-6)
                {
                    dir.replace(cmpt, 0.0);
                }
            }

            dir /= mag(dir);

            pointsDisplacementDir() = dir;
        }

        // TODO: adapt to new framework
        // project the point displacement dirs to the surface on which
        // the A phase is moving if this surface is a wall patch
//        cLine().projectPointDisplDirToWall();

        // Update face displacement direction
        facesDisplacementDir() =
            aMesh().faceAreaNormals().internalField();

        // Correction of control points postion
        const vectorField& Cf = aMesh().areaCentres().internalField();

        controlPoints() =
            facesDisplacementDir()
          * (facesDisplacementDir()&(controlPoints() - Cf))
          + Cf;
    }
}


void Foam::movingInterfacePatches::initializeControlPointsPosition()
{
    scalarField deltaH = scalarField(aMesh().nFaces(), 0.0);

    pointField displacement = pointDisplacement(deltaH);

    const faceList& faces = aMesh().faces();
    const pointField& points = aMesh().points();

    pointField newPoints = points + displacement;

    scalarField sweptVol(faces.size(), 0.0);

    forAll(faces, faceI)
    {
        sweptVol[faceI] = -faces[faceI].sweptVol(points, newPoints);
    }

    vectorField faceArea(faces.size(), vector::zero);

    forAll (faceArea, faceI)
    {
        faceArea[faceI] = faces[faceI].normal(newPoints);
    }

    forAll(deltaH, faceI)
    {
        deltaH[faceI] = sweptVol[faceI]/
            (faceArea[faceI] & facesDisplacementDir()[faceI]);
    }

    forAll(fixedSurfacePatches_, patchI)
    {
        label fixedPatchID =
            aMesh().boundary().findPatchID
            (
                fixedSurfacePatches_[patchI]
            );

        if(fixedPatchID == -1)
        {
            FatalErrorIn("movingInterfacePatches::initializeControlPointsPosition()")
                << "Wrong faPatch name in the fixedSurfacePatches list"
                    << " defined in the dynamicMeshDict dictionary"
                    << abort(FatalError);
        }

        const labelList& eFaces =
            aMesh().boundary()[fixedPatchID].edgeFaces();

        forAll(eFaces, edgeI)
        {
            deltaH[eFaces[edgeI]] *= 2.0;
        }
    }

//    {
//        label centerLinePatchID =
//            aMesh().boundary().findPatchID("centerline");

//        const labelList& eFaces =
//            aMesh().boundary()[centerLinePatchID].edgeFaces();

//        forAll(eFaces, edgeI)
//        {
//            deltaH[eFaces[edgeI]] *= 2.0;
//        }
//    }

    displacement = pointDisplacement(deltaH);
}


void Foam::movingInterfacePatches::correctPointDisplacement
(
    const scalarField& sweptVolCorr,
    vectorField& displacement
)
{
    const labelListList& pFaces =
        aMesh().patch().pointFaces();

    const faceList& faces =
        aMesh().patch().localFaces();

    const pointField& points =
        aMesh().patch().localPoints();

    forAll(fixedSurfacePatches_, patchI)
    {
        label fixedPatchID =
            aMesh().boundary().findPatchID
            (
                fixedSurfacePatches_[patchI]
            );

        const labelList& pLabels =
            aMesh().boundary()[fixedPatchID].pointLabels();

        const labelList& eFaces =
            aMesh().boundary()[fixedPatchID].edgeFaces();

        labelHashSet pointSet;

        forAll(eFaces, edgeI)
        {
            label curFace = eFaces[edgeI];

            const labelList& curPoints = faces[curFace];

            forAll(curPoints, pointI)
            {
                label curPoint = curPoints[pointI];
                label index = findIndex(pLabels, curPoint);

                if (index == -1)
                {
                    if (!pointSet.found(curPoint))
                    {
                        pointSet.insert(curPoint);
                    }
                }
            }
        }

        labelList corrPoints = pointSet.toc();

        labelListList corrPointFaces(corrPoints.size());

        forAll(corrPoints, pointI)
        {
            label curPoint = corrPoints[pointI];

            labelHashSet faceSet;

            forAll(pFaces[curPoint], faceI)
            {
                label curFace = pFaces[curPoint][faceI];

                label index = findIndex(eFaces, curFace);

                if (index != -1)
                {
                    if (!faceSet.found(curFace))
                    {
                        faceSet.insert(curFace);
                    }
                }
            }

            corrPointFaces[pointI] = faceSet.toc();
        }

        forAll(corrPoints, pointI)
        {
            label curPoint = corrPoints[pointI];

            scalar curDisp = 0;

            const labelList& curPointFaces = corrPointFaces[pointI];

            forAll(curPointFaces, faceI)
            {
                const face& curFace = faces[curPointFaces[faceI]];

                label ptInFace = curFace.which(curPoint);
                label next = curFace.nextLabel(ptInFace);
                label prev = curFace.prevLabel(ptInFace);

                vector a = points[next] - points[curPoint];
                vector b = points[prev] - points[curPoint];
                const vector& c = pointsDisplacementDir()[curPoint];

                curDisp += 2*sweptVolCorr[curPointFaces[faceI]]/((a^b)&c);
            }

            curDisp /= curPointFaces.size();

            displacement[curPoint] =
                curDisp*pointsDisplacementDir()[curPoint];
        }
    }
}


void Foam::movingInterfacePatches::makeGlobalPatches() const
{
    if (globalPatchPtr_.valid() || globalNbrPatchPtr_.valid())
    {
        FatalErrorIn(type() + "::makeGlobalPatches() const")
            << "Pointer already set!" << abort(FatalError);
    }

    Info<< "Creating global patches : "
        << patch().name() << " and "
        << nbrPatch().name() << " for movingInterfacePatches "
        << name_
        << endl;

    globalPatchPtr_.set(new globalPolyPatch(patch().name(), mesh()));
    globalNbrPatchPtr_.set(new globalPolyPatch(nbrPatch().name(), nbrMesh()));
}

void Foam::movingInterfacePatches::clearGlobalPatches() const
{
    globalPatchPtr_.clear();
    globalNbrPatchPtr_.clear();
}


void Foam::movingInterfacePatches::makeInterfaceToInterface() const
{
    if (interfaceToInterfacePtr_.valid())
    {
        FatalErrorIn
        (
            "void Foam::movingInterfacePatches::"
            "makeInterfaceToInterface() const"
        )   << "Mapping object already set!" << abort(FatalError);
    }

    Info<< "Creating new interpolator for movingInterfacePatches"
        << endl;

    // Lookup the type
    const word type = motionDict_.lookupOrDefault<word>
    (
        "interfaceTransferMethod", "GGI"
    );

    if (isFsiInterface_)
    {
        Info<< endl << "Moving " << nbrMesh().name()
            << " in the deformed configuration" << endl;

        // TODO: Check if neighbour mesh is a solid region

        // Get mesh points of solid mesh in initial configuration
        newNbrMeshPointsPtr_.reset(new pointField(nbrMesh().allPoints()));

        // Get point displacement field of solid region
        const pointVectorField& pointD =
            nbrMesh().lookupObject<pointVectorField>("pointD");

        // Add current displacement to mesh points
        newNbrMeshPointsPtr_() += pointD;

        // Move the mesh in the deformed configuration
        const_cast<dynamicFvMesh&>(nbrMesh()).movePoints(newNbrMeshPointsPtr_());

        Info<< "Creating updated interpolator" << endl;

        // Create interface to interface mapping
        interfaceToInterfacePtr_ =
        (
            interfaceToInterfaceMapping::New
            (
                type,
                motionDict_.subDict(type + "Coeffs"),
                mesh().boundaryMesh()[patchID()],
                nbrMesh().boundaryMesh()[nbrPatch().index()],
                globalPatch(),
                globalNbrPatch()
            )
        );

        Info<< "Moving " << nbrMesh().name()
            << " back in the initial configuration" << endl;

        // Substract displacement from mesh points again
        newNbrMeshPointsPtr_() -= pointD;

        // Move the mesh back in the initial configuration
        const_cast<dynamicFvMesh&>(nbrMesh()).movePoints(newNbrMeshPointsPtr_());

        // Set moving switch of mesh to be false again
        const_cast<dynamicFvMesh&>(nbrMesh()).moving(false);

    }
    else
    {
        interfaceToInterfacePtr_ =
        (
            interfaceToInterfaceMapping::New
            (
                type,
                motionDict_.subDict(type + "Coeffs"),
                mesh().boundaryMesh()[patchID()],
                nbrMesh().boundaryMesh()[nbrPatch().index()],
                globalPatch(),
                globalNbrPatch()
            )
        );
    }
}

void movingInterfacePatches::clearOut() const
{
    if (isInterface_)
    {
        clearGlobalPatches();
//        globalPatchPtr_().updateMesh();
//        globalNbrPatchPtr_().updateMesh();
        interfaceToInterfacePtr_.clear();
    }

//    aMeshPtr_.clear();
    controlPointsPtr_.clear();
    motionPointsMaskPtr_.clear();
    pointsDisplacementDirPtr_.clear();
    facesDisplacementDirPtr_.clear();
    totalDisplacementPtr_.clear();
    totalSweptVolCorrPtr_.clear();
}

Foam::tmp<vectorField>
Foam::movingInterfacePatches::pointDisplacementPredictor()
{
    Info<< "Predict point displacement for " << name_ << endl;

    meshMotionTrigger_ = false;
    movePatch_ = false;

    const pointField& points = aMesh().patch().localPoints();

    tmp<vectorField> tdisplacement
    (
        new vectorField
        (
            points.size(),
            vector::zero
        )
    );

    vectorField& displacement = tdisplacement();

    if(!totalDisplacementPtr_.empty())
    {
        newMeshPoints_ = mesh().allPoints();

        // Move whole mesh only if interface deformation limit is exceeded
        // Note: This check is supposed to be done for every interface in
        // the list, thus triggering mesh motion automatically if the
        // individual limit is exceeded by ONE of the moving interfaces.
        scalar minCellThickness =
            2*gMin(1.0/mesh().boundary()[patchID()].deltaCoeffs());

        scalar maxInterfaceDeformation =
            gMax(mag(totalDisplacement()))/minCellThickness;

        // For interfaces the cell defomration on the other side also needs to
        // taken into account
        if (isInterface_ && !isFsiInterface_)
        {
            scalar minNbrCellThickness =
                2*gMin(1.0/nbrMesh().boundary()[nbrPatchID()].deltaCoeffs());

            scalar maxNbrInterfaceDeformation =
                gMax(mag(totalDisplacement()))/minNbrCellThickness;

            maxInterfaceDeformation = max
                (
                    maxInterfaceDeformation,
                    maxNbrInterfaceDeformation
                );
        }

        Info << "Maximal relative interface deformation: "
            << maxInterfaceDeformation << endl;

        if
        (
            maxInterfaceDeformation > interfaceDeformationLimit_.value()
        )
        {
            // Set patch points for motion
            const labelList& meshPoints =
                mesh().boundaryMesh()[patchID()].meshPoints();

            forAll (totalDisplacement(), pointI)
            {
                newMeshPoints_[meshPoints[pointI]]
                    -= totalDisplacement()[pointI];
            }

            {
                twoDPointCorrector twoDPointCorr(mesh());

                twoDPointCorr.correctPoints(newMeshPoints_);
            }

            if (isInterface_ && !isFsiInterface_)
            {
                // Set patch points of neighbour mesh for motion
                newNbrMeshPointsPtr_.reset(new pointField(nbrMesh().allPoints()));

                const labelList& nbrMeshPoints =
                    nbrMesh().boundaryMesh()[nbrPatchID()].meshPoints();

                vectorField nbrTotalDisplacement =
                    shadowPointDisplacement(totalDisplacement());

                forAll (nbrTotalDisplacement, pointI)
                {
                    newNbrMeshPointsPtr_()[nbrMeshPoints[pointI]] -=
                        nbrTotalDisplacement[pointI];
                }

                {
                    twoDPointCorrector twoDPointCorr(nbrMesh());

                    twoDPointCorr.correctPoints(newNbrMeshPointsPtr_());
                }
            }

            displacement = totalDisplacement();
            totalDisplacementPtr_.clear();

            if (!isFsiInterface_ && !totalSweptVolCorrPtr_.empty())
            {
                sweptVolCorrOld_ = totalSweptVolCorr();
                totalSweptVolCorrPtr_.clear();
            }

            Info << "Setting mesh motion trigger to true" << endl;
            meshMotionTrigger_ = true;
            movePatch_ = true;
        }
    }

    return tdisplacement;
}

Foam::tmp<vectorField>
Foam::movingInterfacePatches::pointDisplacementCorrector()
{
    Info<< "Correct point displacement for " << name_ << endl;

    meshMotionTrigger_ = false;
    movePatch_ = false;

    const pointField& points = aMesh().patch().localPoints();

    tmp<vectorField> tdisplacement
    (
        new vectorField
        (
            points.size(),
            vector::zero
        )
    );

    vectorField& displacement = tdisplacement();


    if (isInterface_ && !isFsiInterface_)
    {
        const surfaceScalarField& phi =
            mesh().lookupObject<surfaceScalarField>("phi");

        // This is currently absolute flux
        scalarField sweptVolCorr =
            phi.boundaryField()[patchID()];

        Info<< "phi boundary field BEFORE mesh motion :"
            << " sum local = " << gSum(mag(sweptVolCorr))
            << ", global = " << gSum(sweptVolCorr)
            << endl;

        const volVectorField& U =
            mesh().objectRegistry::lookupObject<volVectorField>("U");

        const volScalarField& rho =
            mesh().objectRegistry::lookupObject<volScalarField>("rho");

        sweptVolCorr -=
            fvc::meshPhi(rho, U)().boundaryField()[patchID()];

        Info<< "mesh.phi boundary field BEFORE mesh motion :"
            << " sum local = " << gSum(mag(mesh().phi().boundaryField()[patchID()]))
            << ", global = " << gSum(mesh().phi().boundaryField()[patchID()])
            << endl;

        Info<< "mesh.phi old time boundary field BEFORE mesh motion :"
            << " sum local = " << gSum(mag(mesh().phi().oldTime().boundaryField()[patchID()]))
            << ", global = " << gSum(mesh().phi().oldTime().boundaryField()[patchID()])
            << endl;

        Info<< "fvc::meshPhi boundary field BEFORE mesh motion :"
            << " sum local = " << gSum(mag(fvc::meshPhi(rho, U)().boundaryField()[patchID()]))
            << ", global = " << gSum(fvc::meshPhi(rho, U)().boundaryField()[patchID()])
            << endl;

        newMeshPoints_ = mesh().allPoints();
        newNbrMeshPointsPtr_.reset(new pointField(nbrMesh().allPoints()));

        Info<< "Moving surface continuity error BEFORE mesh motion :"
            << " sum local = " << gSum(mag(sweptVolCorr))
            << ", global = " << gSum(sweptVolCorr)
            << endl;

        word ddtScheme
        (
            mesh().schemesDict().ddtScheme
            (
                "ddt(" + U.name() + ')'
            )
        );

        if
        (
            ddtScheme
         == fv::CrankNicolsonDdtScheme<vector>::typeName
        )
        {
            sweptVolCorr *= (1.0/2.0)*mesh().time().deltaT().value();
        }
        else if
        (
            ddtScheme
         == fv::EulerDdtScheme<vector>::typeName
        )
        {
            sweptVolCorr *= mesh().time().deltaT().value();
        }
        else if
        (
            (ddtScheme == "bdf2")
         ||
            (ddtScheme == fv::backwardDdtScheme<vector>::typeName)
        )
        {
            if (mesh().time().timeIndex() == 1)
            {
                sweptVolCorr *= mesh().time().deltaT().value();
            }
            else
            {
                sweptVolCorr *= (2.0/3.0)*mesh().time().deltaT().value();

                //sweptVolCorr += (1.0/3.0)*sweptVolCorrOld_;
            }
        }
        else
        {
            FatalErrorInFunction
                << "Unsupported temporal differencing scheme : "
                << ddtScheme << nl
                << abort(FatalError);
        }

        // Update total swept volume correction
        totalSweptVolCorr() += sweptVolCorr;

        const scalarField& Sf = aMesh().S();
        const vectorField& Nf = aMesh().faceAreaNormals().internalField();

        scalarField deltaHf
        (
            sweptVolCorr/(Sf*(Nf & facesDisplacementDir()))
        );

        forAll(fixedSurfacePatches_, patchI)
        {
            label fixedPatchID =
                aMesh().boundary().findPatchID
                (
                    fixedSurfacePatches_[patchI]
                );

            if(fixedPatchID == -1)
            {
                FatalErrorIn("interfaceTrackingFvMesh::update(...)")
                    << "Wrong faPatch name in the fixedSurfacePatches list"
                        << " defined in the surfaceProperties dictionary"
                        << abort(FatalError);
            }

            const labelList& eFaces =
                aMesh().boundary()[fixedPatchID].edgeFaces();

            forAll(eFaces, edgeI)
            {
                deltaHf[eFaces[edgeI]] *= 2.0;
            }
        }

       // {
       //     label centerLinePatchID =
       //         aMesh().boundary().findPatchID("centerline");

       //     const labelList& eFaces =
       //         aMesh().boundary()[centerLinePatchID].edgeFaces();

       //     forAll(eFaces, edgeI)
       //     {
       //         deltaHf[eFaces[edgeI]] *= 2.0;
       //     }
       // }

        displacement = pointDisplacement(deltaHf);

        //- correct point displacement for fixed surface patches
        correctPointDisplacement(sweptVolCorr, displacement);

        // Set patch points for motion
        const labelList& meshPoints =
           mesh().boundaryMesh()[patchID()].meshPoints();

        //Info << "meshPoints size: " << returnReduce(meshPoints.size(), sumOp<label>()) << endl;

        forAll (displacement, pointI)
        {
           newMeshPoints_[meshPoints[pointI]] += displacement[pointI];
        }

        {
            twoDPointCorrector twoDPointCorr(mesh());

            twoDPointCorr.correctPoints(newMeshPoints_);
        }

        const labelList& nbrMeshPoints =
            nbrMesh().boundaryMesh()[nbrPatchID()].meshPoints();

        //Info << "nbrMeshPoints size: " << returnReduce(nbrMeshPoints.size(), sumOp<label>()) << endl;

        vectorField nbrDisplacement= shadowPointDisplacement(displacement);

        forAll (nbrDisplacement, pointI)
        {
            newNbrMeshPointsPtr_()[nbrMeshPoints[pointI]]
                += nbrDisplacement[pointI];
        }

        {
            twoDPointCorrector twoDPointCorr(nbrMesh());

            twoDPointCorr.correctPoints(newNbrMeshPointsPtr_());
        }

        // Update total displacement field
        totalDisplacement() += displacement;

        // Move whole mesh only if interface deformation limit is exceeded
        // Note: This check is supposed to be done for every interface in
        // the list, thus triggering mesh motion automatically if the
        // individual limit is exceeded by ONE of the moving interfaces.
        scalar minCellThickness =
            2*gMin(1.0/mesh().boundary()[patchID()].deltaCoeffs());

        scalar maxInterfaceDeformation =
            gMax(mag(totalDisplacement()))/minCellThickness;


        // For interfaces the cell defomration on the other side also needs to
        // taken into account
        scalar minNbrCellThickness =
            2*gMin(1.0/nbrMesh().boundary()[nbrPatchID()].deltaCoeffs());

        scalar maxNbrInterfaceDeformation =
            gMax(mag(totalDisplacement()))/minNbrCellThickness;

        maxInterfaceDeformation = max
            (
                maxInterfaceDeformation,
                maxNbrInterfaceDeformation
            );

        Info << "Maximal relative interface deformation: "
            << maxInterfaceDeformation << endl;

        // if
        // (
        //    maxInterfaceDeformation > interfaceDeformationLimit_.value()
        // )
        // {
        //     // Set patch points for motion
        //     const labelList& meshPoints =
        //         mesh().boundaryMesh()[patchID()].meshPoints();

        //     forAll (totalDisplacement(), pointI)
        //     {
        //         newMeshPoints_[meshPoints[pointI]]
        //             -= totalDisplacement()[pointI] - displacement[pointI];
        //     }

        //     {
        //         twoDPointCorrector twoDPointCorr(mesh());

        //         twoDPointCorr.correctPoints(newMeshPoints_);
        //     }

        //     const labelList& nbrMeshPoints =
        //         nbrMesh().boundaryMesh()[nbrPatchID()].meshPoints();

        //     vectorField nbrTotalDisplacement =
        //         shadowPointDisplacement(totalDisplacement() - displacement);

        //     forAll (nbrTotalDisplacement, pointI)
        //     {
        //         newNbrMeshPointsPtr_()[nbrMeshPoints[pointI]] -=
        //             nbrTotalDisplacement[pointI];
        //     }

        //     {
        //         twoDPointCorrector twoDPointCorr(nbrMesh());

        //         twoDPointCorr.correctPoints(newNbrMeshPointsPtr_());
        //     }

        //     displacement = totalDisplacement();

        //     totalDisplacementPtr_.clear();

        //     meshMotionTrigger_ = true;
        //     movePatch_ = true;
        // }
        // else
        // {
            meshMotionTrigger_ = false;
            movePatch_ = true;
        // }

        // Enforce interface motion based on actual flux (without artefacts),
        // by reset of residual fluxes across free surface
        if
        (
            ((timeIndex_-1) % resetFluxFrequency_) == 0
         && timeIndex_ > 1
        )
        {
            //- Non-const access to flux on patch
            fvsPatchField<scalar>& surfacePhiField =
                const_cast<fvsPatchField<scalar>& >
                (
                    mesh().lookupObject<surfaceScalarField>("phi")
                    .boundaryField()[patchID()]
                );

            surfacePhiField *= 0;
        }
    }
    else if (isInterface_ && isFsiInterface_)
    {
        //- Update the new mesh points after previous predictor or corrector
        newMeshPoints_ = mesh().allPoints();

        // Get the displacement of the solid region
        displacement = getSolidPointDisplacement();

        // Set patch points for motion
        const labelList& meshPoints =
           mesh().boundaryMesh()[patchID()].meshPoints();

        //Info << "meshPoints size: " << returnReduce(meshPoints.size(), sumOp<label>()) << endl;

        forAll (displacement, pointI)
        {
           newMeshPoints_[meshPoints[pointI]] += displacement[pointI];
        }

        {
            twoDPointCorrector twoDPointCorr(mesh());

            twoDPointCorr.correctPoints(newMeshPoints_);
        }

        // Update total displacement field
        totalDisplacement() += displacement;

        // Move whole mesh only if interface deformation limit is exceeded
        // Note: This check is supposed to be done for every interface in
        // the list, thus triggering mesh motion automatically if the
        // individual limit is exceeded by ONE of the moving interfaces.
        scalar minCellThickness =
            2*gMin(1.0/mesh().boundary()[patchID()].deltaCoeffs());

        scalar maxInterfaceDeformation =
            gMax(mag(totalDisplacement()))/minCellThickness;

        Info << "Maximal relative interface deformation: "
            << maxInterfaceDeformation << endl;

        // if
        // (
        //    maxInterfaceDeformation > interfaceDeformationLimit_.value()
        // )
        // {
        //     // Set patch points for motion
        //     const labelList& meshPoints =
        //         mesh().boundaryMesh()[patchID()].meshPoints();

        //     forAll (totalDisplacement(), pointI)
        //     {
        //         newMeshPoints_[meshPoints[pointI]]
        //             -= totalDisplacement()[pointI] - displacement[pointI];
        //     }

        //     {
        //         twoDPointCorrector twoDPointCorr(mesh());

        //         twoDPointCorr.correctPoints(newMeshPoints_);
        //     }

        //     displacement = totalDisplacement();

        //     totalDisplacementPtr_.clear();

        //     meshMotionTrigger_ = true;
        //     movePatch_ = true;
        // }
        // else
        // {
            meshMotionTrigger_ = false;
            movePatch_ = true;
        // }

    }
    else
    {
        notImplemented
        (
            "movingInterfacePatches::surfacePointDisplacement()\n"
            "Rigid free-surface model\n"
            "not implemented"
        );
    }

    return tdisplacement;
}

// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

Foam::movingInterfacePatches::movingInterfacePatches
(
    const word& name,
    const dynamicFvMesh& mesh,
    const dictionary& dict
)
:
    MeshObject<fvMesh, movingInterfacePatches>(mesh),
    name_(name),
    mesh_(mesh),
    newMeshPoints_(mesh.allPoints()),
    newNbrMeshPointsPtr_(),
    aMeshPtr_(new faMesh(mesh)),
//    aMeshPtr_(new faMesh(mesh, "faMeshDefinition")),
    motionDict_(dict),
    surfacePatchID_
    (
        mesh.boundaryMesh().findPatchID(name_)
    ),
    surfacePatch_(mesh.boundary()[surfacePatchID_]),
    fixedSurfacePatches_(),
    nonReflectingFreeSurfacePatches_(),
    pointNormalsCorrectionPatches_(),
    normalMotionDir_
    (
        motionDict_.lookup("normalMotionDir")
    ),
    motionDir_(pTraits<vector>::zero),
    smoothing_(false),
    smoothingFrequency_(1),
    smoothingTolerance_(1e-3),
    isInterface_(false),
    isFsiInterface_
    (
        motionDict_.lookupOrDefault<Switch>("fsiInterface", false)
    ),
    rigidFreeSurface_
    (
        motionDict_.lookupOrDefault<Switch>("rigidFreeSurface", false)
    ),
    meshMotionTrigger_(true),
    movePatch_(false),
    interfaceDeformationLimit_
    (
        motionDict_.lookupOrDefault<dimensionedScalar>
        (
            "interfaceDeformationLimit",
            dimensionedScalar("interfaceDeformationLimit", dimLength, 0.0)
        )
    ),
    timeIndex_(-1),
    sweptVolCorrOld_(mesh.boundaryMesh()[surfacePatchID_].size(), 0.0),
    resetFluxFrequency_
    (
        motionDict_.lookupOrDefault<label>("resetFluxFrequency", 100)
    ),
    neighbourRegionName_
    (
        motionDict_
        .lookupOrDefault<word>("neighbourMesh", word::null)
    ),
    neighbourPatchName_
    (
        motionDict_
        .lookupOrDefault<word>("neighbourPatch", word::null)
    ),
    controlPointsPtr_(),
    totalDisplacementPtr_(),
    prevDisplacementPtr_(),
    totalSweptVolCorrPtr_(),
    motionPointsMaskPtr_(),
    pointsDisplacementDirPtr_(),
    facesDisplacementDirPtr_(),
//    contactAnglePtr_(nullptr)
    globalPatchPtr_(),
    globalNbrPatchPtr_(),
    interfaceToInterfacePtr_(),
    accModelPtr_(),
    interpolatorUpdateFrequency_
    (
        motionDict_
        .lookupOrDefault<int>("interpolatorUpdateFrequency", 0)
    )
{
    initializeData();
}


// * * * * * * * * * * * * * * * * Destructor  * * * * * * * * * * * * * * * //

Foam::movingInterfacePatches::~movingInterfacePatches()
{
    clearOut();
}


// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

//void Foam::movingInterfacePatches::updateTopology()
//{
//    controlPointsPtr_.clear();
//    motionPointsMaskPtr_.clear();
//    pointsDisplacementDirPtr_.clear();
//    facesDisplacementDirPtr_.clear();
//    totalDisplacementPtr_.clear();

//    if (isInterface_)
//    {
//        clearGlobalPatches();
////        globalPatchPtr_().updateMesh();
////        globalNbrPatchPtr_().updateMesh();
//    }
//}

const Foam::dynamicFvMesh& Foam::movingInterfacePatches::nbrMesh() const
{
    return
    (
        mesh().objectRegistry::parent()
        .lookupObject<dynamicFvMesh>(neighbourRegionName_)
    );
}

const Foam::fvPatch& Foam::movingInterfacePatches::nbrPatch() const
{
    return
    (
        nbrMesh().boundary()[nbrPatchID()]
    );
}

Foam::vectorField& Foam::movingInterfacePatches::controlPoints()
{
    if (controlPointsPtr_.empty())
    {
        makeControlPoints();
    }

    return controlPointsPtr_();
}

Foam::vectorField& Foam::movingInterfacePatches::totalDisplacement()
{
    if (totalDisplacementPtr_.empty())
    {
        makeTotalDisplacement();
    }

    return totalDisplacementPtr_();
}

Foam::vectorField& Foam::movingInterfacePatches::prevDisplacement()
{
    if (prevDisplacementPtr_.empty())
    {
        makePrevDisplacement();
    }

    return prevDisplacementPtr_();
}

Foam::scalarField& Foam::movingInterfacePatches::totalSweptVolCorr()
{
    if (totalSweptVolCorrPtr_.empty())
    {
        makeTotalSweptVolCorr();
    }

    return totalSweptVolCorrPtr_();
}


Foam::scalarField& Foam::movingInterfacePatches::motionPointsMask()
{
    if (motionPointsMaskPtr_.empty())
    {
        makeMotionPointsMask();
    }

    return motionPointsMaskPtr_();
}


Foam::vectorField& Foam::movingInterfacePatches::pointsDisplacementDir()
{
    if (pointsDisplacementDirPtr_.empty())
    {
        makeDirections();
    }

    return pointsDisplacementDirPtr_();
}


Foam::vectorField& Foam::movingInterfacePatches::facesDisplacementDir()
{
    if (facesDisplacementDirPtr_.empty())
    {
        makeDirections();
    }

    return facesDisplacementDirPtr_();
}

Foam::accelerationModel<vector>& Foam::movingInterfacePatches::accModel()
{
    if (accModelPtr_.empty())
    {
        makeAccModel();
    }

    return accModelPtr_();
}



Foam::tmp<vectorField>
Foam::movingInterfacePatches::surfacePointDisplacement()
{
    if (motionDict_.found("neighbourMesh"))
    {
        if (timeIndex_ == -1) //initial only / do not move into constructor
        {
            // Create global patches synced in parallel runs such that
            // all faces are present on all processors
            makeGlobalPatches();

            // Force creation of interface-to-interface object
            // as they may need to read fields on restart
            interfaceToInterface();

            if (isInterface_)
            {
                newNbrMeshPointsPtr_.reset(new pointField(nbrMesh().allPoints()));
            }
        }

        // topological change
        if
        (
            timeIndex_ >= 0
         && (mesh().changing() && !mesh().moving())
        )
        {
            makeGlobalPatches();
        }
    }

    // if (!rigidFreeSurface_)
    // {
    //     clearControlPoints();
    // }

    // updateDisplacementDirections();

    if (isInterface_)
    {
        updateInterpolatorAndGlobalPatches();
    }

    // Point motion predictor
    if (timeIndex_ < mesh().time().timeIndex())
    {
        timeIndex_ = mesh().time().timeIndex();

        return tmp<vectorField>
        (
            new vectorField
            (
                this->pointDisplacementPredictor()
            )
        );
    }

    // Point motion corrector
    return tmp<vectorField>
    (
        new vectorField
        (
            this->pointDisplacementCorrector()
        )
    );
}

Foam::tmp<vectorField>
Foam::movingInterfacePatches::shadowPointDisplacement
(
    const vectorField& displacement
)
{
    tmp<vectorField> shadowDisplacement
    (
        new vectorField(displacement.size())
    );

    // Interpolate displacement to global patch point data
    vectorField globalDisplacement =
        globalPatch().patchPointToGlobal(displacement);

    // Create global displacement field for globalNbrPatch
    vectorField globalShadowDisplacement(globalNbrPatch().globalPatch().nPoints());

    // Interpolate globally patch-to-patch
    interfaceToInterface().transferPointsZoneToZone
    (
        globalPatch().globalPatch(),        // from zone
        globalNbrPatch().globalPatch(),     // to zone
        globalDisplacement,                 // from field
        globalShadowDisplacement            // to field
    );

    // Move global patch points due to mesh motion
    globalPatchPtr_().movePoints(globalDisplacement);
    globalNbrPatchPtr_().movePoints(globalShadowDisplacement);

    // Filter global patch point data to patch
    shadowDisplacement() = globalNbrPatch().globalPointToPatch
    (
        globalShadowDisplacement
    );

    // Return
    return shadowDisplacement;
}

Foam::tmp<vectorField>
Foam::movingInterfacePatches::getSolidPointDisplacement()
{
    // !!! Be carefull: pointD is total displacement of solid
    // but we need incremental displacement for the mesh/patch movement

    tmp<vectorField> tIncFluidDisplacement
    (
        new vectorField(patch().patch().nPoints())
    );
    vectorField& incFluidDisplacement = tIncFluidDisplacement();

    // Create global displacement field for globalPatch
    vectorField globalShadowSolidDisplacement(globalPatch().globalPatch().nPoints());

    // Get point displacement field of solid region
    const pointVectorField& pointD =
        nbrMesh().lookupObject<pointVectorField>("pointD");

    const vectorField patchPointD =
        pointD.boundaryField()[nbrPatchID()].patchInternalField();

    // Collect local patch displacement on global patch
    vectorField globalSolidDisplacement =
        globalNbrPatch().patchPointToGlobal(patchPointD);

    // Interpolate globally patch-to-patch
    interfaceToInterface().transferPointsZoneToZone
    (
        globalNbrPatch().globalPatch(),     // from zone
        globalPatch().globalPatch(),        // to zone
        globalSolidDisplacement,            // from field
        globalShadowSolidDisplacement       // to field
    );

    // Move global patch points due to mesh motion
    //globalPatchPtr_().movePoints(globalShadowSolidDisplacement);
    //globalNbrPatchPtr_().movePoints(globalSolidDisplacement);

    // Filter global patch point data to patch
    vectorField shadowSolidDisplacement = globalPatch().globalPointToPatch
    (
        globalShadowSolidDisplacement
    );

    // Relax the displacement on fluid side
    accModel().relax(shadowSolidDisplacement);

    // Turn mapped total displacement from solid into incremental displacement
    // for fluid
    incFluidDisplacement = shadowSolidDisplacement - prevDisplacement();

    prevDisplacement() = shadowSolidDisplacement;

    // Return
    return tIncFluidDisplacement;
}

void Foam::movingInterfacePatches::enforcePatchMotion()
{
    Info<< "Moving patch "
        << mesh().boundaryMesh()[patchID()].name()
        << endl;

    const_cast<dynamicFvMesh&>(mesh()).movePoints(newMeshPoints_);
}

void Foam::movingInterfacePatches::enforceShadowPatchMotion()
{
    Info<< "Moving neighbour patch "
        << nbrMesh().boundaryMesh()[nbrPatchID()].name()
        << endl;

    const_cast<dynamicFvMesh&>(nbrMesh()).movePoints(newNbrMeshPointsPtr_());
}

Foam::tmp<vectorField>
movingInterfacePatches::smoothSurfaceMesh()
{
    const pointField& points = aMesh().patch().localPoints();

    tmp<vectorField> tdisplacement
    (
        new vectorField
        (
            points.size(),
            vector::zero
        )
    );

    if
    (
        !smoothing_
     || (mesh().time().timeIndex() % smoothingFrequency_) != 0
    )
    {
        return tdisplacement;
    }

    vectorField& displacement = tdisplacement();

    const vectorField& oldPoints = aMesh().patch().localPoints();

    vectorField newPoints = oldPoints;

    const labelListList& pointEdges = aMesh().patch().pointEdges();

    const labelListList& pointFaces = aMesh().patch().pointFaces();

    const edgeList& edges = aMesh().patch().edges();

    const faceList& faces = aMesh().patch().localFaces();

    const labelList& boundaryPoints = aMesh().patch().boundaryPoints();

    Info << "Smoothing free-surface mesh" << endl;

    // Average edge length
    scalar avgEdgeLength = 0;

    forAll(edges, edgeI)
    {
        avgEdgeLength += edges[edgeI].mag(oldPoints);
    }
    avgEdgeLength /= edges.size();

    // Smooth boundary points
    forAll(aMesh().boundary(), patchI)
    {
        if (aMesh().boundary()[patchI].coupled())
        {
            continue;
        }

        const labelList& pPointLabels =
            aMesh().boundary()[patchI].pointLabels();

        const labelListList& pPointEdges =
            aMesh().boundary()[patchI].pointEdges();

        const edgeList::subList pEdges =
            aMesh().boundary()[patchI].patchSlice(aMesh().edges());


        // Find fixed points
        boolList fixedPoints(pPointLabels.size(), false);

        forAll(fixedPoints, pointI)
        {
            if (pPointEdges[pointI].size() == 1)
            {
                fixedPoints[pointI] = true;
            }
        }


        // Performe smoothing
        scalarField residual(pPointLabels.size(), 0);
        label counter = 0;
        do
        {
            counter++;

            forAll(pPointLabels, pointI)
            {
                if (!fixedPoints[pointI])
                {
                    vector curNewPoint = vector::zero;

                    forAll(pPointEdges[pointI], eI)
                    {
                        label curEdgeIndex = pPointEdges[pointI][eI];

                        const edge& curEdge = pEdges[curEdgeIndex];

                        vector d =
                            newPoints
                            [
                                curEdge.otherVertex(pPointLabels[pointI])
                            ]
                          - newPoints[pPointLabels[pointI]];

                        curNewPoint += d;
                    }

                    curNewPoint /= pPointEdges[pointI].size();

                    curNewPoint += newPoints[pPointLabels[pointI]];


                    // Project new point to the interface
                    label nearestPointID = -1;
                    scalar minDist = GREAT;
                    forAll(pPointLabels, pI)
                    {
                        label curPoint = pPointLabels[pI];

                        scalar dist = mag(curNewPoint - oldPoints[curPoint]);

                        if (dist < minDist)
                        {
                            nearestPointID = pI;
                            minDist = dist;
                        }
                    }

                    bool foundProjection = false;
                    forAll(pPointEdges[nearestPointID], edgeI)
                    {
                        label edgeID = pPointEdges[nearestPointID][edgeI];

                        vector eTilda =
                            oldPoints
                            [
                                pEdges[edgeID]
                               .otherVertex(pPointLabels[nearestPointID])
                            ]
                          - oldPoints[pPointLabels[nearestPointID]];

                        scalar eMag = mag(eTilda);

                        eTilda /= mag(eTilda);

                        vector t =
                            eTilda
                           *(
                                eTilda
                               &(
                                    curNewPoint
                                  - oldPoints[pPointLabels[nearestPointID]]
                                )
                            );

                        if
                        (
                            ((t&eTilda) >= 0)
                         && ((t&eTilda) <= eMag)
                        )
                        {
                            curNewPoint =
                                oldPoints[pPointLabels[nearestPointID]] + t;
                            foundProjection = true;
                            break;
                        }
                    }

                    if (!foundProjection)
                    {
                        FatalErrorIn("movingInterfacePatches::smoothMesh()")
                            << "Could not project patch point to surface"
                                << abort(FatalError);
                    }

                    residual[pointI] =
                        mag(curNewPoint - newPoints[pPointLabels[pointI]])
                       /(
                           mag(curNewPoint - oldPoints[pPointLabels[pointI]])
                         + SMALL
                        );

                    newPoints[pPointLabels[pointI]] = curNewPoint;
                }
            }
        }
        while(max(residual) > smoothingTolerance_);

        Info << "Patch: " << aMesh().boundary()[patchI].name()
            << ", max residual: " << max(residual)
            << ", num of iterations: " << counter << endl;
    }


    // Smooth internal points
    boolList fixedPoints(newPoints.size(), false);

    forAll(boundaryPoints, pointI)
    {
        fixedPoints[boundaryPoints[pointI]] = true;
    }

    scalarField residual(newPoints.size(), 0);
    label counter = 0;
    do
    {
        counter++;

        forAll(newPoints, pointI)
        {
            if (!fixedPoints[pointI])
            {
                vector curNewPoint = vector::zero;

                scalar sumW = 0;

                forAll(pointEdges[pointI], eI)
                {
                    label curEdgeIndex = pointEdges[pointI][eI];

                    const edge& curEdge = edges[curEdgeIndex];

                    vector d =
                        newPoints[curEdge.otherVertex(pointI)]
                      - newPoints[pointI];

//                     scalar w = 1.0;
                    scalar w = curEdge.mag(newPoints)/avgEdgeLength;

                    curNewPoint += w*d;

                    sumW += w;
                }

                curNewPoint /= sumW;

                curNewPoint += newPoints[pointI];


                // Project new point to the interface
                label nearestPointID = -1;
                scalar minDist = GREAT;
                forAll(oldPoints, pI)
                {
                    scalar dist = mag(curNewPoint - oldPoints[pI]);

                    if (dist < minDist)
                    {
                        nearestPointID = pI;
                        minDist = dist;
                    }
                }

                const vector& n = aMesh().pointAreaNormals()[nearestPointID];

                pointHit ph(curNewPoint);

                forAll(pointFaces[nearestPointID], faceI)
                {
                    label faceID = pointFaces[nearestPointID][faceI];

                    ph = faces[faceID].ray(curNewPoint, n, oldPoints);

                    if (ph.hit())
                    {
                        curNewPoint = ph.hitPoint();
                        break;
                    }
                }

                // if (!ph.hit())
                // {
                //     Info << counter << ", " << pointI << endl;

                //     FatalErrorIn("movingInterfacePatches::smoothMesh()")
                //         << "Could not project point to surface"
                //             << abort(FatalError);
                // }

                residual[pointI] =
                    mag(curNewPoint - newPoints[pointI])
                   /(
                        mag(curNewPoint - oldPoints[pointI])
                      + SMALL
                    );

                newPoints[pointI] = curNewPoint;
            }
        }
    }
    while(max(residual) > 1e-3);

    Info << "Internal points, max residual: " << max(residual)
            << ", num of iterations: " << counter << endl;

    // Mesh statistic
    scalar minEdge = GREAT;
    scalar avgEdge = 0;
    scalar maxEdge = SMALL;

    forAll(edges, edgeI)
    {
        scalar curEdgeLength = edges[edgeI].mag(newPoints);

        if (curEdgeLength < minEdge)
        {
            minEdge = curEdgeLength;
        }

        if (curEdgeLength > maxEdge)
        {
            maxEdge = curEdgeLength;
        }

        avgEdge += curEdgeLength;
    }
    avgEdge /= edges.size();

    Info << "Edge length, min: " << minEdge
        << ", max: " << maxEdge << ", avg: " << avgEdge << endl;

    displacement = newPoints - oldPoints;

    return tdisplacement;
}

void movingInterfacePatches::correctPointNormals()
{
    // Correct normals for fixed patches points
    Info << "Correct point normals" << endl;

    vectorField& N =
        const_cast<vectorField&>
        (
            aMesh().pointAreaNormals()
        );

    const labelListList& pFaces =
        aMesh().patch().pointFaces();

    const labelListList& fFaces =
        aMesh().patch().faceFaces();

    const faceList& faces =
        aMesh().patch().localFaces();

    const pointField& points =
        aMesh().patch().localPoints();

    // Wedge points
//    forAll(aMesh().boundary(), patchI)
//    {
//        if (aMesh().boundary()[patchI].type() == wedgeFaPatch::typeName)
//        {
//            const wedgeFaPatch& wedgePatch =
//                refCast<const wedgeFaPatch>(aMesh().boundary()[patchI]);

//            const labelList& patchPoints = wedgePatch.pointLabels();

//            forAll(patchPoints, pointI)
//            {
//                label curPoint = patchPoints[pointI];

//                labelHashSet faceSet;
//                forAll(pFaces[curPoint], faceI)
//                {
//                    faceSet.insert(pFaces[curPoint][faceI]);
//                }
//                labelList curFaces = faceSet.toc();
//
//                labelHashSet pointSet;

//                pointSet.insert(curPoint);
//                for(label i=0; i<curFaces.size(); i++)
//                {
//                    const labelList& facePoints = faces[curFaces[i]];
//                    for(label j=0; j<facePoints.size(); j++)
//                    {
//                        if(!pointSet.found(facePoints[j]))
//                        {
//                            pointSet.insert(facePoints[j]);
//                        }
//                    }
//                }
//                pointSet.erase(curPoint);
//                labelList curPoints = pointSet.toc();

//
//                labelHashSet addPointsSet;
//                forAll(curPoints, pointI)
//                {
//                    label index =
//                        findIndex(patchPoints, curPoints[pointI]);

//                    if (index != -1)
//                    {
//                        addPointsSet.insert(curPoints[pointI]);
//                    }
//                }
//                addPointsSet.insert(curPoint);
//                labelList curAddPoints = addPointsSet.toc();


//                if (curPoints.size() + curAddPoints.size() >= 5)
//                {
//                    vectorField allPoints
//                    (
//                        curPoints.size()+curAddPoints.size()
//                    );
//                    scalarField W(curPoints.size()+curAddPoints.size(), 1.0);
//                    label I = -1;
//                    for(label i=0; i<curPoints.size(); i++)
//                    {
//                        I++;
//                        allPoints[I] = points[curPoints[i]];
//                        W[I] = 1.0/magSqr(allPoints[I] - points[curPoint]);
//                    }
//                    for(label i=0; i<curAddPoints.size(); i++)
//                    {
//                        I++;
//                        allPoints[I] =
//                            transform
//                            (
//                                wedgePatch.faceT(),
//                                points[curAddPoints[i]]
//                            );
//                        W[I] = 1.0/magSqr(allPoints[I] - points[curPoint]);
//                    }

//                    // Transforme points
//                    vector origin = points[curPoint];
//                    vector axis = N[curPoint]/mag(N[curPoint]);
//                    vector dir = (allPoints[0] - points[curPoint]);
//                    dir -= axis*(axis&dir);
//                    dir /= mag(dir);
//                    coordinateSystem cs("cs", origin, axis, dir);
//
//                    forAll(allPoints, pI)
//                    {
//                        allPoints[pI] = cs.localPosition(allPoints[pI]);
//                    }
//
//                    scalarRectangularMatrix M
//                    (
//                        allPoints.size(),
//                        5,
//                        0.0
//                    );

//                    for(label i = 0; i < allPoints.size(); i++)
//                    {
//                        M[i][0] = sqr(allPoints[i].x());
//                        M[i][1] = sqr(allPoints[i].y());
//                        M[i][2] = allPoints[i].x()*allPoints[i].y();
//                        M[i][3] = allPoints[i].x();
//                        M[i][4] = allPoints[i].y();
//                    }
//
//                    scalarSquareMatrix MtM(5, 0.0);

//                    for (label i = 0; i < MtM.n(); i++)
//                    {
//                        for (label j = 0; j < MtM.m(); j++)
//                        {
//                            for (label k = 0; k < M.n(); k++)
//                            {
//                                MtM[i][j] += M[k][i]*M[k][j]*W[k];
//                            }
//                        }
//                    }
//
//                    scalarField MtR(5, 0);

//                    for (label i=0; i<MtR.size(); i++)
//                    {
//                        for (label j=0; j<M.n(); j++)
//                        {
//                            MtR[i] += M[j][i]*allPoints[j].z()*W[j];
//                        }
//                    }
//
//                    scalarSquareMatrix::LUsolve(MtM, MtR);

//                    vector curNormal = vector(MtR[3], MtR[4], -1);
//
//                    curNormal = cs.globalVector(curNormal);
//
//                    curNormal *= sign(curNormal&N[curPoint]);
//
//                    N[curPoint] = curNormal;
//                }
//            }
//        }
//    }

    // Fixed boundary points

    forAll(fixedSurfacePatches_, patchI)
    {
        label fixedPatchID =
            aMesh().boundary().findPatchID
            (
                fixedSurfacePatches_[patchI]
            );

        if(fixedPatchID == -1)
        {
            FatalErrorIn("movingInterfacePatches::correctPointNormals()")
                << "Wrong faPatch name in the fixedSurfacePatches list"
                    << " defined in the surfaceProperties dictionary"
                    << abort(FatalError);
        }

        const labelList& pLabels =
            aMesh().boundary()[fixedPatchID].pointLabels();

        const labelList& eFaces =
            aMesh().boundary()[fixedPatchID].edgeFaces();

        forAll(pLabels, pointI)
        {
            label curPoint = pLabels[pointI];

            labelHashSet faceSet;
            forAll(pFaces[curPoint], faceI)
            {
                faceSet.insert(pFaces[curPoint][faceI]);
            }

            labelList curFaces = faceSet.toc();

            forAll(curFaces, faceI)
            {
                const labelList& curFaceFaces =
                    fFaces[curFaces[faceI]];

                forAll(curFaceFaces, fI)
                {
                    label curFaceFace = curFaceFaces[fI];

                    label index = findIndex(eFaces, curFaceFace);

                    if( (index==-1) && !faceSet.found(curFaceFace) )
                    {
                        faceSet.insert(curFaceFace);
                    }
                }
            }
            curFaces = faceSet.toc();

            labelHashSet pointSet;

            pointSet.insert(curPoint);
            for(label i=0; i<curFaces.size(); i++)
            {
                const labelList& fPoints = faces[curFaces[i]];
                for(label j=0; j<fPoints.size(); j++)
                {
                    if(!pointSet.found(fPoints[j]))
                    {
                        pointSet.insert(fPoints[j]);
                    }
                }
            }

            pointSet.erase(curPoint);

            labelList curPoints = pointSet.toc();

            // LS quadric fit
            vectorField allPoints(curPoints.size());
            scalarField W(curPoints.size(), 1.0);
            for(label i=0; i<curPoints.size(); i++)
            {
                allPoints[i] = points[curPoints[i]];
                W[i] = 1.0/magSqr(allPoints[i] - points[curPoint]);
            }

            // Transforme points
            vector origin = points[curPoint];
            vector axis = N[curPoint]/mag(N[curPoint]);
            vector dir = (allPoints[0] - points[curPoint]);
            dir -= axis*(axis&dir);
            dir /= mag(dir);
            coordinateSystem cs("cs", origin, axis, dir);

            forAll(allPoints, pI)
            {
                allPoints[pI] = cs.localPosition(allPoints[pI]);
            }

            scalarRectangularMatrix M
            (
                allPoints.size(),
                5,
                0.0
            );

            for(label i = 0; i < allPoints.size(); i++)
            {
                M[i][0] = sqr(allPoints[i].x());
                M[i][1] = sqr(allPoints[i].y());
                M[i][2] = allPoints[i].x()*allPoints[i].y();
                M[i][3] = allPoints[i].x();
                M[i][4] = allPoints[i].y();
            }

            scalarSquareMatrix MtM(5, 0.0);

            for (label i = 0; i < MtM.n(); i++)
            {
                for (label j = 0; j < MtM.m(); j++)
                {
                    for (label k = 0; k < M.n(); k++)
                    {
                        MtM[i][j] += M[k][i]*M[k][j]*W[k];
                    }
                }
            }

            scalarField MtR(5, 0);

            for (label i=0; i<MtR.size(); i++)
            {
                for (label j=0; j<M.n(); j++)
                {
                    MtR[i] += M[j][i]*allPoints[j].z()*W[j];
                }
            }

            scalarSquareMatrix::LUsolve(MtM, MtR);

            vector curNormal = vector(MtR[3], MtR[4], -1);

            curNormal = cs.globalVector(curNormal);

            curNormal *= sign(curNormal&N[curPoint]);

            N[curPoint] = curNormal;
        }
    }

    // Correcte wedge points
//    forAll (aMesh().boundary(), patchI)
//    {
//        if (aMesh().boundary()[patchI].type() == wedgeFaPatch::typeName)
//        {
//            const wedgeFaPatch& wedgePatch =
//                refCast<const wedgeFaPatch>(aMesh().boundary()[patchI]);

//            const labelList& patchPoints = wedgePatch.pointLabels();

//            vector n =
//                transform
//                (
//                    wedgePatch.edgeT(),
//                    wedgePatch.centreNormal()
//                );

//            n /= mag(n);

//            forAll (patchPoints, pointI)
//            {
//                N[patchPoints[pointI]]
//                    -= n*(n&N[patchPoints[pointI]]);
//            }
//        }
//    }


    // Boundary points correction
    forAll (aMesh().boundary(), patchI)
    {
        if
        (
            aMesh().correctPatchPointNormals(patchI)
        && !aMesh().boundary()[patchI].coupled()
        )
        {
            if (aMesh().boundary()[patchI].ngbPolyPatchIndex() == -1)
            {
                FatalErrorIn
                    (
                        "void correctPointNormals::correctPointNormals()"
                    )   << "Neighbour polyPatch index is not defined "
                        << "for faPatch " << aMesh().boundary()[patchI].name()
                        << abort(FatalError);
            }

            labelList patchPoints = aMesh().boundary()[patchI].pointLabels();

            vectorField n =
                aMesh().boundary()[patchI].ngbPolyPatchPointNormals();

            forAll (patchPoints, pointI)
            {
                N[patchPoints[pointI]]
                    -= n[pointI]*(n[pointI]&N[patchPoints[pointI]]);
            }
        }
    }


    N /= mag(N);
}

const Foam::interfaceToInterfaceMapping&
Foam::movingInterfacePatches::interfaceToInterface() const
{
    if (interfaceToInterfacePtr_.empty())
    {
        makeInterfaceToInterface();
    }

    return interfaceToInterfacePtr_();
}


const Foam::globalPolyPatch& Foam::movingInterfacePatches::globalPatch() const
{
    if (globalPatchPtr_.empty())
    {
        FatalErrorIn(type() + "::makeGlobalPatch() const")
            << "makeGlobalPatches(...) must be called before globalPatchA "
            << "can be called!" << abort(FatalError);
    }

    return globalPatchPtr_();
}

const Foam::globalPolyPatch& Foam::movingInterfacePatches::globalNbrPatch() const
{
    if (globalNbrPatchPtr_.empty())
    {
        FatalErrorIn(type() + "::makeGlobalPatch() const")
            << "makeGlobalPatches(...) must be called before globalPatchA "
            << "can be called!" << abort(FatalError);
    }

    return globalNbrPatchPtr_();
}


void Foam::movingInterfacePatches::updateInterpolatorAndGlobalPatches()
{
    if (interfaceToInterfacePtr_.empty())
    {
        interfaceToInterface();
    }
    else if (interpolatorUpdateFrequency_ != 0)
    {
        if
        (
            (
                (mesh().time().timeIndex() - 1) % interpolatorUpdateFrequency_
            ) == 0
        )
        {
            Info<< "Updating interpolator and global patches for movingInterfacePatches"
                << endl;

            // Enforce topology update
//            updateTopology();

            // Re-create interpolators
            interfaceToInterfacePtr_.clear();

            // Clear and re-create global patches
            clearGlobalPatches();
            makeGlobalPatches();

            // Re-create interpolators
            interfaceToInterface();
        }
    }
}


// Update for mesh motion
bool Foam::movingInterfacePatches::movePoints() const
{
    return true;
}


// Update on topology change
bool Foam::movingInterfacePatches::updateMesh(const mapPolyMesh& mpm) const
{
//    if (debug)
    {
        Info<< "Clearing out movingInterfacePatches after topology change"
            << endl;
    }

    // Wipe out demand-driven data
//    clearOut();
//    deleteObject();
//    makeFaMesh();
//    makeGlobalPatches();
//    interfaceToInterface();

    return true;
}


void Foam::movingInterfacePatches::writeVTK() const
{
    // Write patch and points into VTK
    OFstream mps(mesh().time().timePath()/name_+".vtk");

    const vectorField& points = aMesh().patch().points();
    const IndirectList<face>& faces = aMesh().patch();

    mps << "# vtk DataFile Version 2.0" << nl
        << mesh().time().timePath()/name_+".vtk" << nl
        << "ASCII" << nl
        << "DATASET POLYDATA" << nl
        << "POINTS " << points.size() << " float" << nl;

    // Write points
    List<float> mlpBuffer(3*points.size());

    label counter = 0;
    forAll(points, i)
    {
        mlpBuffer[counter++] = float(points[i].x());
        mlpBuffer[counter++] = float(points[i].y());
        mlpBuffer[counter++] = float(points[i].z());
    }

    forAll(mlpBuffer, i)
    {
        mps << mlpBuffer[i] << ' ';

        if (i > 0 && (i % 10) == 0)
        {
            mps << nl;
        }
    }

    // Write faces
    label nFaceVerts = 0;

    forAll(faces, faceI)
    {
        nFaceVerts += faces[faceI].size() + 1;
    }
    labelList mlfBuffer(nFaceVerts);

    counter = 0;
    forAll(faces, faceI)
    {
        const face& f = faces[faceI];

        mlfBuffer[counter++] = f.size();

        forAll(f, fpI)
        {
            mlfBuffer[counter++] = f[fpI];
        }
    }
    mps << nl;

    mps << "POLYGONS " << faces.size() << ' ' << nFaceVerts << endl;

    forAll(mlfBuffer, i)
    {
        mps << mlfBuffer[i] << ' ';

        if (i > 0 && (i % 10) == 0)
        {
            mps << nl;
        }
    }
    mps << nl;

     aMesh().patch().writeVTK
     (
         mesh().time().timePath()/"surface",
         aMesh().patch(),
         aMesh().patch().points()
     );
}


void Foam::movingInterfacePatches::writeVTKControlPoints()
{
    // Write control points into VTK
    fileName name(mesh().time().timePath()/name_+"ControlPoints.vtk");
    OFstream mps(name);

    Info<< "Writing surface control point to " << name << endl;

    mps << "# vtk DataFile Version 2.0" << nl
        << name << nl
        << "ASCII" << nl
        << "DATASET POLYDATA" << nl
        << "POINTS " << controlPoints().size() << " float" << nl;

    forAll(controlPoints(), pointI)
    {
        mps << controlPoints()[pointI].x() << ' '
            << controlPoints()[pointI].y() << ' '
            << controlPoints()[pointI].z() << nl;
    }

    // Write vertices
    mps << "VERTICES " << controlPoints().size() << ' '
        << controlPoints().size()*2 << nl;

    forAll(controlPoints(), pointI)
    {
        mps << 1 << ' ' << pointI << nl;
    }
}


// ************************************************************************* //
